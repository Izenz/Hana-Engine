class A 
{
	int* ptr;
	A() { ptr = new int(4);}
	~A() { delete ptr;}
	
	void copy(const A& obj{		// for lvalues
		delete ptr;
		ptr = obj.ptr;
	}
	
	void copy(A&& obj)		// for rvalues
	{
		delete ptr;
		ptr = obj.ptr;
		obj.ptr = nullptr;
	}
}

void main()
{
	A obj0; // I create an object theres a new 
	A obj1; // I create an object theres a new 
	obj0.copy(obj1); // Memory leak unless you call destructor.
} // Crash because we delete obj0 ptr and when we try to delete obj1 ptr it gives a reference to obj0 which is already destroyed.

/*** In order to solve this line 9 should be something like this: ptr = new int(*obj.ptr); ***/


----------------

class A 
{
	int* ptr;
	A() { ptr = new int(4);}
	~A() { delete ptr;}
	
	void copy(const A& obj{
	delete ptr;
	ptr = obj.ptr;
	
}

void main()
{
	int i = 0;
	if(i == 0{
		A obj0;
		obj0.copy(A()); // WE can do this because the function recieves a const rvalue ref, if it wasnt const it would give compilation error.
		// If it recieves A&& obj and we called copy(A("asdkjnasd")) -> Because nobody is going to use the value we pass to the function is better if we use a temporary object.
	}
}

--------------

if instead of obj.copy(obj1) I use obj.copy(std::move(obj1)); We would be calling the second functions for rvalues even tho im using lvalue.
We could also have

void copy(A&& obj)		// for rvalues
{
	copy(std::forward(obj));
}

-----------------

Examples for move constructuro...

void main(){
	std::vector<std::vector<int> > v;
	
	std::vector<int> v2;
	v2.push_back(3); // int* ptr malloc(sizeof(int))*1 allocates one element of ints and in the first position allocates a 3;
	v.push_back(v2); // In 98 C++ what happens is std::vector<std::vector<int> >* ptr = malloc(sizeof(std::vector<int> 1*) allocates one vector and in the first position, v2 is copied.
	This means we have to allocate again a new ptr like the first v2 push back. In order to copy a vector into a vector of vectors I have to reallocate the integer vectors because if I dont
	I will have a crash when I try to delete pointers. This is why we never did this back in 98 C++. Nowadays is still a nightmare of optimization so we never do it either.
	And everytime we do a pushback it has to be reallocated again
	
	// How do we solve this?? Move operator.
}

You would do something like
v.push_back(std::vector<int>(3);
or v.push_back(std::move(v2)); No reallocations will be done.
Whenever you need to copy an object that needs to move around or copy pointers, use the move function to do it.

-----------------------------------

new vector v = func();

std::vector<int> func(){
	std::vector<int> v;
	v.pushback(1);
	v.push back(2);
	
	return v;
}

What happens after calling functions in previous c++ is that memory is allocated and then it returns and then the full vectors should be copied into v. That means reallocations, etc.
But with move operator compiller knows that vectors in the function are temporary, instead just copies the pointer.
Never return a reference to a vector inside a class that is not const, for encapsulation you want to manage that vector inside the class.

------------------

unique_ptr
Most common use pointer*

void main(){
	std::unique_ptr<A> a = std::make_unique<A>();
} // Automatically calls destroyed when out of the scope.

If you have a class of type B and you have a pointer inside you probably want to make it unique pointer because it will manage it automatically.
------------------

shared_ptr

Each time it is copied it increments its references and until all references are removed, which removes one everytime a destroyer is called.
When you want to share a pointer between several classes that none of them own. Each time you copy this pointer references are added and everytime you remove a reference to it
references are reduced and when no references are made it is deleted.

weak_ptr

When you need ciclic pointers, f.e. classA pointer to class B and classB pointer to class A, if both are shared they will never be deleted. You break this dependence by using weak ptr.

------------
 lamba example
 
class B {
	std::vector<std::string> name;
	
	void find(const std::string n){
	
		int a ;
		a = 5;
		
		auto func = [n, a](const std::string& str) --> bool // I can get the value 54 because its copied and it can be used.
		{
			return str.length() == a;
		}
		
		std::find_if(names.begin(), names.end(), func) != names.end();
	}
}

func is embedded inside the find function, and i can capture values of the function or inside the class even.
Here im capturin the parameter n and it recieves anything and it finds n inside the names of the vector.

This can be useful for STL algorithms.
Basically this lambda function when you pass it on the fly it calls func for each of the names and it compares if the length of each name is the same as a.
It selects the first name that matches the length specified.